// Code generated by protoc-gen-go.
// source: storage.proto
// DO NOT EDIT!

/*
Package storage is a generated protocol buffer package.

It is generated from these files:
	storage.proto

It has these top-level messages:
	ListRequest
	ListReply
	NewRequest
	NewReply
	SetRequest
	SetReply
	GetRequest
	GetReply
	RemoveRequest
	RemoveReply
	Experiment
	Param
	Value
	Namespace
	Segments
*/
package storage

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ListRequest retuns all the experiments from the given environment.
type ListRequest struct {
	Query string `protobuf:"bytes,1,opt,name=query" json:"query,omitempty"`
}

func (m *ListRequest) Reset()                    { *m = ListRequest{} }
func (m *ListRequest) String() string            { return proto.CompactTextString(m) }
func (*ListRequest) ProtoMessage()               {}
func (*ListRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ListRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

// The response message containing the Experiments
type ListReply struct {
	Experiments []*Experiment `protobuf:"bytes,1,rep,name=experiments" json:"experiments,omitempty"`
}

func (m *ListReply) Reset()                    { *m = ListReply{} }
func (m *ListReply) String() string            { return proto.CompactTextString(m) }
func (*ListReply) ProtoMessage()               {}
func (*ListReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ListReply) GetExperiments() []*Experiment {
	if m != nil {
		return m.Experiments
	}
	return nil
}

// NewRequest represents a request to create a new experiment and
// potentially a new namespace.
type NewRequest struct {
	Experiment *Experiment `protobuf:"bytes,1,opt,name=experiment" json:"experiment,omitempty"`
	Namespace  *Namespace  `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	ESegments  int64       `protobuf:"varint,3,opt,name=eSegments" json:"eSegments,omitempty"`
	NSegments  int64       `protobuf:"varint,4,opt,name=nSegments" json:"nSegments,omitempty"`
}

func (m *NewRequest) Reset()                    { *m = NewRequest{} }
func (m *NewRequest) String() string            { return proto.CompactTextString(m) }
func (*NewRequest) ProtoMessage()               {}
func (*NewRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *NewRequest) GetExperiment() *Experiment {
	if m != nil {
		return m.Experiment
	}
	return nil
}

func (m *NewRequest) GetNamespace() *Namespace {
	if m != nil {
		return m.Namespace
	}
	return nil
}

func (m *NewRequest) GetESegments() int64 {
	if m != nil {
		return m.ESegments
	}
	return 0
}

func (m *NewRequest) GetNSegments() int64 {
	if m != nil {
		return m.NSegments
	}
	return 0
}

// NewReply represents a response from the New rpc.
type NewReply struct {
	Experiment *Experiment `protobuf:"bytes,1,opt,name=experiment" json:"experiment,omitempty"`
	Namespace  *Namespace  `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *NewReply) Reset()                    { *m = NewReply{} }
func (m *NewReply) String() string            { return proto.CompactTextString(m) }
func (*NewReply) ProtoMessage()               {}
func (*NewReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *NewReply) GetExperiment() *Experiment {
	if m != nil {
		return m.Experiment
	}
	return nil
}

func (m *NewReply) GetNamespace() *Namespace {
	if m != nil {
		return m.Namespace
	}
	return nil
}

// SetRequest request message to create a new experiment in an
// environment.
type SetRequest struct {
	Experiment *Experiment `protobuf:"bytes,1,opt,name=experiment" json:"experiment,omitempty"`
	Namespace  *Namespace  `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *SetRequest) Reset()                    { *m = SetRequest{} }
func (m *SetRequest) String() string            { return proto.CompactTextString(m) }
func (*SetRequest) ProtoMessage()               {}
func (*SetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SetRequest) GetExperiment() *Experiment {
	if m != nil {
		return m.Experiment
	}
	return nil
}

func (m *SetRequest) GetNamespace() *Namespace {
	if m != nil {
		return m.Namespace
	}
	return nil
}

// SetReply response containing the newly created Experiment.
type SetReply struct {
	Experiment *Experiment `protobuf:"bytes,1,opt,name=experiment" json:"experiment,omitempty"`
	Namespace  *Namespace  `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *SetReply) Reset()                    { *m = SetReply{} }
func (m *SetReply) String() string            { return proto.CompactTextString(m) }
func (*SetReply) ProtoMessage()               {}
func (*SetReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SetReply) GetExperiment() *Experiment {
	if m != nil {
		return m.Experiment
	}
	return nil
}

func (m *SetReply) GetNamespace() *Namespace {
	if m != nil {
		return m.Namespace
	}
	return nil
}

// GetRequest request message to get an experiment by id.
type GetRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (m *GetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GetRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// GetReply response containing then experiment requested.
type GetReply struct {
	Experiment *Experiment `protobuf:"bytes,1,opt,name=experiment" json:"experiment,omitempty"`
	Namespace  *Namespace  `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *GetReply) Reset()                    { *m = GetReply{} }
func (m *GetReply) String() string            { return proto.CompactTextString(m) }
func (*GetReply) ProtoMessage()               {}
func (*GetReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GetReply) GetExperiment() *Experiment {
	if m != nil {
		return m.Experiment
	}
	return nil
}

func (m *GetReply) GetNamespace() *Namespace {
	if m != nil {
		return m.Namespace
	}
	return nil
}

// RemoveRequest request message to remove an existing experiment from
// an environment.
type RemoveRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *RemoveRequest) Reset()                    { *m = RemoveRequest{} }
func (m *RemoveRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoveRequest) ProtoMessage()               {}
func (*RemoveRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *RemoveRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// RemoveReply response containing the removed experiment.
type RemoveReply struct {
	Experiment *Experiment `protobuf:"bytes,1,opt,name=experiment" json:"experiment,omitempty"`
	Namespace  *Namespace  `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *RemoveReply) Reset()                    { *m = RemoveReply{} }
func (m *RemoveReply) String() string            { return proto.CompactTextString(m) }
func (*RemoveReply) ProtoMessage()               {}
func (*RemoveReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *RemoveReply) GetExperiment() *Experiment {
	if m != nil {
		return m.Experiment
	}
	return nil
}

func (m *RemoveReply) GetNamespace() *Namespace {
	if m != nil {
		return m.Namespace
	}
	return nil
}

// Experiment structure
type Experiment struct {
	Id         string            `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name       string            `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Namespace  string            `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
	Labels     map[string]string `protobuf:"bytes,4,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Params     []*Param          `protobuf:"bytes,5,rep,name=params" json:"params,omitempty"`
	Segments   *Segments         `protobuf:"bytes,6,opt,name=segments" json:"segments,omitempty"`
	DetailName string            `protobuf:"bytes,7,opt,name=detailName" json:"detailName,omitempty"`
}

func (m *Experiment) Reset()                    { *m = Experiment{} }
func (m *Experiment) String() string            { return proto.CompactTextString(m) }
func (*Experiment) ProtoMessage()               {}
func (*Experiment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Experiment) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Experiment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Experiment) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Experiment) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Experiment) GetParams() []*Param {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Experiment) GetSegments() *Segments {
	if m != nil {
		return m.Segments
	}
	return nil
}

func (m *Experiment) GetDetailName() string {
	if m != nil {
		return m.DetailName
	}
	return ""
}

// Param structure
type Param struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value *Value `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *Param) Reset()                    { *m = Param{} }
func (m *Param) String() string            { return proto.CompactTextString(m) }
func (*Param) ProtoMessage()               {}
func (*Param) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Param) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Param) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// Value structure
type Value struct {
	Choices []string  `protobuf:"bytes,1,rep,name=choices" json:"choices,omitempty"`
	Weights []float64 `protobuf:"fixed64,2,rep,packed,name=weights" json:"weights,omitempty"`
}

func (m *Value) Reset()                    { *m = Value{} }
func (m *Value) String() string            { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()               {}
func (*Value) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Value) GetChoices() []string {
	if m != nil {
		return m.Choices
	}
	return nil
}

func (m *Value) GetWeights() []float64 {
	if m != nil {
		return m.Weights
	}
	return nil
}

type Namespace struct {
	Name        string    `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	NumSegments int64     `protobuf:"varint,2,opt,name=numSegments" json:"numSegments,omitempty"`
	Segments    *Segments `protobuf:"bytes,3,opt,name=segments" json:"segments,omitempty"`
}

func (m *Namespace) Reset()                    { *m = Namespace{} }
func (m *Namespace) String() string            { return proto.CompactTextString(m) }
func (*Namespace) ProtoMessage()               {}
func (*Namespace) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Namespace) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Namespace) GetNumSegments() int64 {
	if m != nil {
		return m.NumSegments
	}
	return 0
}

func (m *Namespace) GetSegments() *Segments {
	if m != nil {
		return m.Segments
	}
	return nil
}

type Segments struct {
	Len int64  `protobuf:"varint,1,opt,name=len" json:"len,omitempty"`
	B   []byte `protobuf:"bytes,2,opt,name=b,proto3" json:"b,omitempty"`
}

func (m *Segments) Reset()                    { *m = Segments{} }
func (m *Segments) String() string            { return proto.CompactTextString(m) }
func (*Segments) ProtoMessage()               {}
func (*Segments) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Segments) GetLen() int64 {
	if m != nil {
		return m.Len
	}
	return 0
}

func (m *Segments) GetB() []byte {
	if m != nil {
		return m.B
	}
	return nil
}

func init() {
	proto.RegisterType((*ListRequest)(nil), "elwin.storage.ListRequest")
	proto.RegisterType((*ListReply)(nil), "elwin.storage.ListReply")
	proto.RegisterType((*NewRequest)(nil), "elwin.storage.NewRequest")
	proto.RegisterType((*NewReply)(nil), "elwin.storage.NewReply")
	proto.RegisterType((*SetRequest)(nil), "elwin.storage.SetRequest")
	proto.RegisterType((*SetReply)(nil), "elwin.storage.SetReply")
	proto.RegisterType((*GetRequest)(nil), "elwin.storage.GetRequest")
	proto.RegisterType((*GetReply)(nil), "elwin.storage.GetReply")
	proto.RegisterType((*RemoveRequest)(nil), "elwin.storage.RemoveRequest")
	proto.RegisterType((*RemoveReply)(nil), "elwin.storage.RemoveReply")
	proto.RegisterType((*Experiment)(nil), "elwin.storage.Experiment")
	proto.RegisterType((*Param)(nil), "elwin.storage.Param")
	proto.RegisterType((*Value)(nil), "elwin.storage.Value")
	proto.RegisterType((*Namespace)(nil), "elwin.storage.Namespace")
	proto.RegisterType((*Segments)(nil), "elwin.storage.Segments")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ElwinStorage service

type ElwinStorageClient interface {
	// List returns all the experiments that match the selector.
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListReply, error)
	// New creates a new experiment and namespace if needed.
	New(ctx context.Context, in *NewRequest, opts ...grpc.CallOption) (*NewReply, error)
	// Get returns the experiment matching the supplied name from the
	// given environment.
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetReply, error)
	// Set replaces the experiment in the given environment with the
	// experiment supplied.
	Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetReply, error)
	// Remove removes the namespace from the given environment.
	Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveReply, error)
}

type elwinStorageClient struct {
	cc *grpc.ClientConn
}

func NewElwinStorageClient(cc *grpc.ClientConn) ElwinStorageClient {
	return &elwinStorageClient{cc}
}

func (c *elwinStorageClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListReply, error) {
	out := new(ListReply)
	err := grpc.Invoke(ctx, "/elwin.storage.ElwinStorage/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elwinStorageClient) New(ctx context.Context, in *NewRequest, opts ...grpc.CallOption) (*NewReply, error) {
	out := new(NewReply)
	err := grpc.Invoke(ctx, "/elwin.storage.ElwinStorage/New", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elwinStorageClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetReply, error) {
	out := new(GetReply)
	err := grpc.Invoke(ctx, "/elwin.storage.ElwinStorage/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elwinStorageClient) Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetReply, error) {
	out := new(SetReply)
	err := grpc.Invoke(ctx, "/elwin.storage.ElwinStorage/Set", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elwinStorageClient) Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveReply, error) {
	out := new(RemoveReply)
	err := grpc.Invoke(ctx, "/elwin.storage.ElwinStorage/Remove", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ElwinStorage service

type ElwinStorageServer interface {
	// List returns all the experiments that match the selector.
	List(context.Context, *ListRequest) (*ListReply, error)
	// New creates a new experiment and namespace if needed.
	New(context.Context, *NewRequest) (*NewReply, error)
	// Get returns the experiment matching the supplied name from the
	// given environment.
	Get(context.Context, *GetRequest) (*GetReply, error)
	// Set replaces the experiment in the given environment with the
	// experiment supplied.
	Set(context.Context, *SetRequest) (*SetReply, error)
	// Remove removes the namespace from the given environment.
	Remove(context.Context, *RemoveRequest) (*RemoveReply, error)
}

func RegisterElwinStorageServer(s *grpc.Server, srv ElwinStorageServer) {
	s.RegisterService(&_ElwinStorage_serviceDesc, srv)
}

func _ElwinStorage_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElwinStorageServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elwin.storage.ElwinStorage/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElwinStorageServer).List(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElwinStorage_New_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElwinStorageServer).New(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elwin.storage.ElwinStorage/New",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElwinStorageServer).New(ctx, req.(*NewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElwinStorage_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElwinStorageServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elwin.storage.ElwinStorage/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElwinStorageServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElwinStorage_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElwinStorageServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elwin.storage.ElwinStorage/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElwinStorageServer).Set(ctx, req.(*SetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElwinStorage_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElwinStorageServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/elwin.storage.ElwinStorage/Remove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElwinStorageServer).Remove(ctx, req.(*RemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ElwinStorage_serviceDesc = grpc.ServiceDesc{
	ServiceName: "elwin.storage.ElwinStorage",
	HandlerType: (*ElwinStorageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _ElwinStorage_List_Handler,
		},
		{
			MethodName: "New",
			Handler:    _ElwinStorage_New_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ElwinStorage_Get_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _ElwinStorage_Set_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _ElwinStorage_Remove_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "storage.proto",
}

func init() { proto.RegisterFile("storage.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 719 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0xc1, 0x6e, 0xd3, 0x4a,
	0x14, 0x95, 0xed, 0x26, 0x6d, 0xae, 0xd3, 0x2a, 0x9a, 0xd7, 0xf7, 0xea, 0x67, 0x22, 0x88, 0x8c,
	0x90, 0xa2, 0x08, 0xc5, 0xa2, 0x95, 0x10, 0x6d, 0xc5, 0x06, 0xa9, 0x0a, 0x8b, 0xaa, 0x82, 0x89,
	0xc4, 0x82, 0x0d, 0x72, 0x92, 0x8b, 0x6b, 0xe1, 0xd8, 0xae, 0x3d, 0x49, 0x88, 0x50, 0x05, 0xe2,
	0x17, 0xf8, 0x1c, 0x24, 0x7e, 0x80, 0x25, 0xbf, 0xc0, 0x87, 0xa0, 0x19, 0x7b, 0x6c, 0xd7, 0x4d,
	0x10, 0x2b, 0xb2, 0xf3, 0xcc, 0x39, 0xf7, 0xdc, 0x33, 0xb7, 0x9d, 0x33, 0x81, 0xdd, 0x84, 0x85,
	0xb1, 0xe3, 0x62, 0x3f, 0x8a, 0x43, 0x16, 0x92, 0x5d, 0xf4, 0x17, 0x5e, 0xd0, 0xcf, 0x36, 0xcd,
	0xb6, 0x1b, 0x86, 0xae, 0x8f, 0xb6, 0x13, 0x79, 0xb6, 0x13, 0x04, 0x21, 0x73, 0x98, 0x17, 0x06,
	0x49, 0x4a, 0xb6, 0xee, 0x83, 0x7e, 0xee, 0x25, 0x8c, 0xe2, 0xd5, 0x0c, 0x13, 0x46, 0xf6, 0xa1,
	0x76, 0x35, 0xc3, 0x78, 0x69, 0x28, 0x1d, 0xa5, 0xdb, 0xa0, 0xe9, 0xc2, 0x7a, 0x0e, 0x8d, 0x94,
	0x14, 0xf9, 0x4b, 0x72, 0x0a, 0x3a, 0xbe, 0x8f, 0x30, 0xf6, 0xa6, 0x18, 0xb0, 0xc4, 0x50, 0x3a,
	0x5a, 0x57, 0x3f, 0xfc, 0xbf, 0x7f, 0xa3, 0x69, 0xff, 0x2c, 0x67, 0xd0, 0x32, 0xdb, 0xfa, 0xaa,
	0x00, 0x5c, 0xe0, 0x42, 0xb6, 0x3b, 0x06, 0x28, 0x50, 0xd1, 0xf3, 0xb7, 0x52, 0x25, 0x32, 0x79,
	0x0c, 0x8d, 0xc0, 0x99, 0x62, 0x12, 0x39, 0x63, 0x34, 0x54, 0x51, 0x69, 0x54, 0x2a, 0x2f, 0x24,
	0x4e, 0x0b, 0x2a, 0x69, 0x43, 0x03, 0x87, 0xe8, 0xa6, 0xe6, 0xb5, 0x8e, 0xd2, 0xd5, 0x68, 0xb1,
	0xc1, 0xd1, 0x20, 0x47, 0xb7, 0x52, 0x34, 0xdf, 0xb0, 0xae, 0x61, 0x47, 0x98, 0xe7, 0x63, 0xf8,
	0xfb, 0xd6, 0xad, 0x8f, 0x00, 0x43, 0x64, 0x9b, 0x9b, 0x1d, 0x3f, 0xbf, 0x30, 0xb0, 0xa1, 0xf3,
	0xb7, 0x01, 0x06, 0xc5, 0xf9, 0xf7, 0x40, 0xf5, 0x26, 0xd9, 0xff, 0xa9, 0xea, 0x4d, 0xb8, 0xb9,
	0xc1, 0x06, 0xcd, 0xdd, 0x83, 0x5d, 0x8a, 0xd3, 0x70, 0x8e, 0xeb, 0xfc, 0x7d, 0x52, 0x40, 0x97,
	0x8c, 0x0d, 0x79, 0xfc, 0xae, 0x02, 0x14, 0x92, 0x55, 0x87, 0x84, 0xc0, 0x16, 0xe7, 0x0a, 0xc5,
	0x06, 0x15, 0xdf, 0xe2, 0x42, 0xe4, 0xad, 0x34, 0x01, 0x94, 0x2e, 0xd3, 0x53, 0xa8, 0xfb, 0xce,
	0x08, 0x7d, 0x7e, 0x57, 0x78, 0x0c, 0x3c, 0x58, 0xeb, 0xbf, 0x7f, 0x2e, 0x78, 0x67, 0x01, 0x8b,
	0x97, 0x34, 0x2b, 0x22, 0x0f, 0xa1, 0x1e, 0x39, 0xb1, 0x33, 0x4d, 0x8c, 0x9a, 0x28, 0xdf, 0xaf,
	0x94, 0xbf, 0xe0, 0x20, 0xcd, 0x38, 0xe4, 0x08, 0x76, 0x12, 0x79, 0x35, 0xeb, 0xe2, 0xd0, 0x07,
	0x15, 0xbe, 0xbc, 0xa8, 0x34, 0x27, 0x92, 0xbb, 0x00, 0x13, 0x64, 0x8e, 0xe7, 0xf3, 0x81, 0x18,
	0xdb, 0xe2, 0x00, 0xa5, 0x1d, 0xf3, 0x18, 0xf4, 0x92, 0x33, 0xd2, 0x02, 0xed, 0x1d, 0xca, 0xf4,
	0xe3, 0x9f, 0x3c, 0x11, 0xe7, 0x8e, 0x3f, 0x93, 0x53, 0x49, 0x17, 0x27, 0xea, 0x13, 0xc5, 0x1a,
	0x40, 0x4d, 0x18, 0xcc, 0xe7, 0xa6, 0x94, 0xe6, 0xd6, 0x2b, 0x97, 0xdd, 0x3e, 0xd9, 0x2b, 0x8e,
	0x65, 0x62, 0xd6, 0x29, 0xd4, 0xc4, 0x9a, 0x18, 0xb0, 0x3d, 0xbe, 0x0c, 0xbd, 0x31, 0xa6, 0xb1,
	0xda, 0xa0, 0x72, 0xc9, 0x91, 0x05, 0x7a, 0xee, 0x25, 0x4b, 0x0c, 0xb5, 0xa3, 0x75, 0x15, 0x2a,
	0x97, 0xd6, 0x1c, 0x1a, 0xf9, 0xdf, 0x7a, 0xa5, 0x93, 0x0e, 0xe8, 0xc1, 0x6c, 0x9a, 0x87, 0x9a,
	0x2a, 0x42, 0xad, 0xbc, 0x75, 0x63, 0xb0, 0xda, 0x1f, 0x0e, 0xd6, 0xea, 0xf1, 0x2c, 0xc8, 0x04,
	0x5a, 0xa0, 0xf9, 0x18, 0x88, 0xae, 0x1a, 0xe5, 0x9f, 0xa4, 0x09, 0xca, 0x48, 0xb4, 0x6a, 0x52,
	0x65, 0x74, 0xf8, 0x4d, 0x83, 0xe6, 0x19, 0x17, 0x1c, 0xa6, 0x7a, 0x84, 0xc2, 0x16, 0x7f, 0x50,
	0x88, 0x59, 0xe9, 0x53, 0x7a, 0x8a, 0x4c, 0x63, 0x25, 0x16, 0xf9, 0x4b, 0x6b, 0xff, 0xf3, 0x8f,
	0x9f, 0x5f, 0xd4, 0x3d, 0xd2, 0x14, 0x6f, 0xda, 0xfc, 0x91, 0xed, 0x73, 0xad, 0x97, 0xa0, 0x5d,
	0xe0, 0x82, 0x54, 0xaf, 0x50, 0xf1, 0xda, 0x98, 0x07, 0xab, 0x20, 0x2e, 0xf8, 0x9f, 0x10, 0x6c,
	0x59, 0xba, 0x14, 0x0c, 0x70, 0x71, 0xa2, 0xf4, 0xc8, 0x10, 0xb4, 0x01, 0xb2, 0x5b, 0x92, 0x45,
	0x08, 0xdd, 0x92, 0x94, 0x09, 0x64, 0x19, 0x42, 0x92, 0x90, 0x96, 0x94, 0x74, 0x91, 0xd9, 0x1f,
	0xbc, 0xc9, 0x35, 0xf7, 0x39, 0x5c, 0x21, 0x3a, 0x5c, 0x2f, 0x2a, 0x33, 0x57, 0xfa, 0x34, 0x73,
	0x9f, 0x09, 0x32, 0xee, 0xf3, 0x0d, 0xd4, 0xd3, 0x64, 0x21, 0xed, 0x4a, 0xe9, 0x8d, 0x48, 0x32,
	0xcd, 0x35, 0x28, 0xd7, 0xbe, 0x23, 0xb4, 0xff, 0xed, 0xfd, 0x23, 0xb5, 0x63, 0x01, 0x0a, 0xcf,
	0xcf, 0x7a, 0xaf, 0xbb, 0xae, 0xc7, 0x2e, 0x67, 0xa3, 0xfe, 0x38, 0x9c, 0xda, 0x6f, 0xc3, 0xd0,
	0x9f, 0x25, 0x5e, 0x18, 0xd8, 0x42, 0x4e, 0xfc, 0x90, 0x48, 0xec, 0x4c, 0x74, 0x54, 0x17, 0xeb,
	0xa3, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x65, 0x44, 0x2f, 0x8a, 0x96, 0x08, 0x00, 0x00,
}
